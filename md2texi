#!/usr/bin/env node

let fs = require('fs')
let program = require('commander')
let util = require('util')

let ti = require('./lib/texinfo')
let im = require('./lib/infomenu')

let input_src = function() {
    return program.args.length === 0 ? ['/dev/stdin'] : program.args
}

let conf = {
    title: null,
    author: null
}

program
    .version('2.0.0')
    .option('-t, --title <string>', 'Document title')
    .option('-a, --author <string>', 'Document author')
    .option('--info-cat <string>', 'Info category')
    .parse(process.argv)

conf.title = program.title || 'No Title'
conf.author = program.author || 'Anonymous' // TODO
conf.infoCat = program.infoCat || 'Miscellaneous' // TODO

let texi = []
let contents = []

// create a full table of contents (grab menus from all the input files)
for (let file of input_src()) {
    let markdown = fs.readFileSync(file).toString()
    let node_prefix = ti.node_prefix(file)
    let menu = im.menu(markdown, { node_prefix })
//    console.error(util.inspect(menu, {depth: null}))

    contents.push(menu)
}

// actually parse each input file
for (let file of input_src()) {
    console.error(file)
    let markdown = fs.readFileSync(file).toString()
    let node_prefix = ti.node_prefix(file)
    let menu = im.menu(markdown, { node_prefix })

    texi.push(`@c === BEGIN ${file} ===`)
    // use the aforementioned table of contents
    texi.push(ti.markdown2texi(markdown, menu, { node_prefix, menu: contents }))
    texi.push(`@c === END ${file} ===`)
}

// multiple files
if (contents.length > 1) {
    let firstlevelmenu = []
    firstlevelmenu.push("\n@menu")
    for (let submenu of contents) {
	for (let item of submenu.kids) {
	    firstlevelmenu.push(`* ${item.name}: ${item.id}.`)
	}
    }
    firstlevelmenu.push("@end menu\n")
    texi.unshift(firstlevelmenu.join("\n"))
}

process.stdout.write(ti.render(texi.join("\n"), conf))
