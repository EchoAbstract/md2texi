#!/usr/bin/env node

'use strict';

let fs = require('fs')
let path = require('path')
let util = require('util')

let marked = require('marked')
let program = require('commander')
let Mustache = require('mustache')

let meta = require('./package.json')

// copied from marked package
function unescape(html) {
    return html.replace(/&([#\w]+);/g, function(_, n) {
	n = n.toLowerCase();
	if (n === 'colon') return ':';
	if (n.charAt(0) === '#') {
	    return n.charAt(1) === 'x'
		? String.fromCharCode(parseInt(n.substring(2), 16))
		: String.fromCharCode(+n.substring(1));
	}
	return '';
    });
}

let infofile = function(file) {
    return path.basename(file, '.markdown')
}

let template = function(type) {
    return fs.readFileSync(path.join(__dirname, 'templates', `${type}.txt`)).toString()
}

let section = function(level) {
    switch (level) {
    case 1:
	return '@chapter'
	break
    case 2:
	return '@section'
	break
    case 3:
	return '@subsection'
	break
    case 4:
	return '@subsubsection'
	break
    default:
	throw new Error(`level ${level} is not supported`)
    }
}

let humanName = function(text) {
    return text.replace(/[:,\\]/g, ' ')
	.replace(/<.+?>/g, '')  // strip html
	.replace(/\s+/, ' ').trim()
}

class TexiNodeIdGenerator {
    constructor(file) {
	if (!file) throw new Error('file is required')
	this.db = {}
	this.file = file
    }

    prefix() {
	return infofile(this.file).replace(/[^\w\-]/g, '-').replace(/-+/g, '-')
    }

    _id(text) {
	let id = text.toLowerCase()
	    .replace(/<.+?>/g, '')  // strip html
	    .replace(/[^\w]+/g, '_')
	    .replace(/_+/g, '_')
	    .replace(/_$/, '')

	return `${this.prefix()}_${id}`
    }

    get(text) {
	let id = this._id(text)
	let prev = this.db[id]
	if (util.isNumber(prev)) {
	    this.db[id] += 1
	    id = `${id}_${prev + 1}`
	} else {
	    this.db[id] = 0
	}

	return id
    }

    index(text, level) {
	let prefix = this.prefix() + ' '
	if (level < 2) prefix = ''

	if (text.match(/event:/i)) {
	    text = text.replace(/Event:\s+([^(\[]+).*/, '$1').replace(/['"]/g, '')
	    return [`@findex ${prefix}event ${text}`,
		    `@findex event ${prefix}${text}`].join("\n")
	} else {
	    text = text.replace(/([^(\[]+).*/, '$1').replace(/['"]/g, '')
	    return `@findex ${prefix}${humanName(text)}`
	}
    }

}

let texi_escape = function(str) {
    return str.replace(/[@{}]/g, '@$&')
}

class MenuItem {
    constructor(id, humanName, level, parent) {
	this.id = id
	this.humanName = humanName
	this.level = level
	this.parent = null

	this.kids = []
    }

    kid_add(menuitem) {
	if (this.level === menuitem.level - 1) {
	    this.kids.push(menuitem)
	    menuitem.parent = this
	} else {
	    let parent = this.find(menuitem.level - 1)
//	    console.error('%s < %s', menuitem.id, parent.id)
	    parent.kids.push(menuitem)
	    menuitem.parent = parent
	}
    }

    // return a MenuItem object
    find(level) {
	let node = this
	while (true) {
	    if (node.level === level) return node
	    node = node.parent
	    if (!node) throw new Error(`${level} not found, root node reached`)
	}

	// not reached
    }

    find_by_id(id) {
//	console.error(this.id, id)
	if (this.id === id) return this

	let r = null
//	console.error(this.kids.map(function(v) { return v.id }))
	for (let node of this.kids) {
//	    console.error('*', node.id)
	    if (node.id === id) {
//		console.error('  FOUND')
		return node
	    }
	    r = node.find_by_id(id)
	    if (r) break
	}

	return r
    }
}

let make_menu = function(input, file) {
    input = texi_escape(input)
    let renderer = new marked.Renderer()
    let root = new MenuItem(null, null, 0)
    let prev = root
    let tnidg = new TexiNodeIdGenerator(file)

    renderer.heading = function (text, level) {
	text = unescape(text)
	let id = tnidg.get(text)

	let mi = new MenuItem(id, humanName(text), level)
	prev.kid_add(mi)
	prev = mi
    }
    marked(input, { renderer: renderer })
    return root
}

let menuitem2texi = function(root, node_id) {
//    console.error('\n->', node_id)
    let node = root.find_by_id(node_id)
    if (node.kids.length === 0) return ""

//    console.error(node)
    let menu = node.kids.map(function(node) {
	return {
	    id: node.id,
	    humanName: node.humanName
	}
    })
    let r = Mustache.render(template("texi.menu"), {menu: menu})
//    console.error(r)
    return r
}


let texinfo = function(input, file, opt) {
    input = texi_escape(input)
    let renderer = new marked.Renderer()

    let root = make_menu(input, file)
//    console.error(util.inspect(root, {depth: null}))
    let tnidg = new TexiNodeIdGenerator(file)

    renderer.heading = function (text, level) {
//	console.error(text)
	text = unescape(text).replace(/@\w+?{(.+?)}/g, '$1') // strip texinfo
//	console.error(text)
	let id = tnidg.get(text)

	return [`\n@c ${new Array(78).join('-')}`,
		`@node ${id}`,
		`${section(level)} ${humanName(text)}`,
		tnidg.index(text, level),
		'\n',
		menuitem2texi(root, id)].join('\n')
    }

    renderer.code = function(code, lang, escaped) {
	return ['\n',
		'@example',
		unescape(code),
		'@end example',
		'\n'].join("\n")
    }

    renderer.codespan = function(text) {
	return '@code{' + unescape(text) + '}'
    }

    renderer.paragraph = function(text) {
	return '\n' + unescape(text) + '\n'
    }

    renderer.list = function(body, ordered) {
	let type = ordered ? 'enumerate' : 'itemize'
	let r = []
	r.push(`\n@${type}`)
	r.push(body)
	r.push(`\n@end ${type}\n`)
	return r.join('\n')
    }

    renderer.listitem = function(text) {
	return '\n@item ' + unescape(text)
    }

    renderer.em = function(text) {
	return '@emph{' + unescape(text) + '}'
    }

    renderer.strong = function(text) {
	return '@strong{' + unescape(text) + '}'
    }

    renderer.link = function(href, title, text) {
	if (href.match(/^https?:\/\//)) {
	    return `@uref{${href},${text}}`
	}
	if (href.match(/\.html$/)) {
	    href = href.replace(/\.html$/, '')
	    // FIXME: it seems imposible to get this info at runtime
	    let horrible_hack = {
		'fs': 'fs_file_system',
		'vm': 'vm_executing_javascript'
	    }
	    href = horrible_hack[href] ? horrible_hack[href] : href + '_' + href
	} else {
	    href = href.replace(/^(.+)?#/, '')
	}
	return `@ref{${href},${text}}`
    }

    renderer.html = function(html) {
	// strip comments
	if (html.trim().match(/^<!--.*?-->$/)) return ''

	warnx(`${file}: raw html:\n${html}`)
	return html
    }

    renderer.blockquote = function(quote) {
	return '\n@indentedblock\n' + unescape(quote) + '\n@end indentedblock\n'
    }

    let topmenu = ''
    if (!opt.partial) {
	let menu = [
	    { id: root.kids[0].id, humanName: root.kids[0].humanName },
	    { id: 'Index', humanName: 'Index' }
	]
	topmenu = Mustache.render(template("texi.menu"), {menu: menu})
    }
    return {
	topmenu: { id: root.kids[0].id, humanName: root.kids[0].humanName },
	texinfo: [topmenu,
		  marked(input, { renderer: renderer })].join('')
    }
}


/*
  CLI
*/

let conf = {
    tocFull: false,
    tocShort: false,
    title: null,
    partial: false,
    verbose: 0
}

let errx = function(msg) {
    console.error("%s error: %s", path.basename(process.argv[1]), msg)
    process.exit(1)
}

let vputs = function(level, msg) {
    if (level <= conf.verbose) console.error(msg)
}

let warnx = function(msg) {
    vputs(0, `${path.basename(process.argv[1])} warning: ${msg}`)
}

let input_src = function() {
    return program.args.length === 0 ? ['/dev/stdin'] : program.args
}

let input_read = function(source) {
    try {
	return fs.readFileSync(source).toString()
    } catch (err) {
	errx(err.message)
    }
}

let texi = function(ti, file, opt) {
    if (opt.partial) return ti
    let o = {
	opt: opt,
	infofile: infofile(file),
	texi: ti
    }
    return Mustache.render(template('texi.doc'), o)
}


/*
  Main
*/
if (__filename === process.argv[1]) {

    program
	.version(meta.version)
	.option('-v, --verbose', 'Be verbose', function() { conf.verbose++ })
	.option('-p, --partial', 'Generate a partial document')
	.option('-t, --title <string>', 'Document title')
	.option('--toc-full', 'Include full TOC')
	.option('--toc-short', 'Include short TOC')
	.parse(process.argv)

    conf.partial = program.partial
    conf.title = program.title
    conf.tocFull = program.tocFull
    conf.tocShort = program.tocShort

    let multi = input_src().length > 1

    if (multi) conf.partial = true
    vputs(2, util.inspect(conf))

    let menu = []
    let ti = []
    for (let src of input_src()) {
	vputs(1, src)
	let input = input_read(src)
	// conversion md -> texinfo
	let output = texinfo(input, src, conf)

	if (multi) {
	    // don't print, just grab the converted result
	    menu.push(output.topmenu)
	    ti.push(output.texinfo)
	} else {
	    process.stdout.write(texi(output.texinfo, src, conf))
	}
    }

    if (multi) {
	// prepare the top menu
	menu.push({ id: 'Index', humanName: 'Index' })
	let topmenu = Mustache.render(template("texi.menu"), {menu: menu})
	ti.unshift(topmenu)

	// wrap the result
	conf.partial = false
	let output = texi(ti.join(""), conf.title || 'no-title', conf)
	process.stdout.write(output)
    }

} else {
    // for tests
}
